use glium::backend::Facade;
use glium::texture::Cubemap;
use glium::texture::SrgbCubemap;
use glium::texture::{Dimensions, MipmapsOption};
use glium::uniforms::AsUniformValue;
use image::io::Reader as ImageReader;
use image::DynamicImage;
use image::GenericImageView;
use std::error::Error;
use std::ops::Index;
use std::path::PathBuf;
use std::ptr::null;

pub enum CubemapType {
    Cubemap(Cubemap),
    SrgbCubemap(SrgbCubemap),
}

impl From<Cubemap> for CubemapType {
    fn from(c: Cubemap) -> Self {
        Self::Cubemap(c)
    }
}
impl From<SrgbCubemap> for CubemapType {
    fn from(c: SrgbCubemap) -> Self {
        Self::SrgbCubemap(c)
    }
}

impl AsUniformValue for &CubemapType {
    fn as_uniform_value(&self) -> glium::uniforms::UniformValue<'_> {
        match self {
            CubemapType::Cubemap(c) => c.as_uniform_value(),
            CubemapType::SrgbCubemap(c) => c.as_uniform_value(),
        }
    }
}

impl AsUniformValue for CubemapType {
    fn as_uniform_value(&self) -> glium::uniforms::UniformValue<'_> {
        match self {
            CubemapType::Cubemap(c) => c.as_uniform_value(),
            CubemapType::SrgbCubemap(c) => c.as_uniform_value(),
        }
    }
}

pub struct CubemapLoader {}

impl CubemapLoader {
    fn create_paths(mut directory: PathBuf, extension: &str) -> Vec<PathBuf> {
        directory.push(format!("right.{}", extension));
        let path: PathBuf = directory.into();

        vec![
            path.with_file_name(format!("right.{}", extension)),
            path.with_file_name(format!("left.{}", extension)),
            path.with_file_name(format!("top.{}", extension)),
            path.with_file_name(format!("bottom.{}", extension)),
            path.with_file_name(format!("front.{}", extension)),
            path.with_file_name(format!("back.{}", extension)),
        ]
    }

    // Creates a cubemap in raw opengl and then passes the id to glium for glium to manage.
    // I can't find any other way to create a cubemap in glium. This uses some C pointers so there is
    // a high likelihood that this is not robust and is quite easy to make the program panic
    pub fn load_from_fs(directory: PathBuf, extension: &str, facade: &impl Facade) -> CubemapType {
        let images = Self::create_paths(directory, extension)
            .into_iter()
            .map(|path| ImageReader::open(path).unwrap().decode().unwrap());

        let orientation = CubeOrientation::from_array(images).unwrap();

        let cubemap = Self::load_cubemap(facade, vec![orientation]);

        CubemapType::Cubemap(cubemap)
    }

    pub fn load_mips_fs(
        mut directory: PathBuf,
        extension: &str,
        facade: &impl Facade,
    ) -> CubemapType {
        if directory.is_file() {
            directory.pop();
        }

        let mut cubes = Vec::new();
        let mut level = 0;
        while directory.join(format!("{}", level)).exists() {
            let sub_directory = directory.join(format!("{}", level));

            let images = Self::create_paths(sub_directory, extension)
                .into_iter()
                .map(|path| {
                    let image = ImageReader::open(path).unwrap().decode().unwrap();

                    image
                });

            let orientation = CubeOrientation::from_array(images).unwrap();

            cubes.push(orientation);

            level += 1;
        }

        if cubes.len() == 0 {
            println!(
                "Unable to find any directories in {}",
                directory.as_os_str().to_str().unwrap()
            );
        }

        let cubemap = Self::load_cubemap_mips(facade, cubes);

        CubemapType::Cubemap(cubemap)
    }

    fn load_cubemap(facade: &impl Facade, mut cubes: Vec<CubeOrientation>) -> Cubemap {
        unsafe {
            let mut cubemap_id: u32 = 0;
            let num_mips = cubes.len() - 1;
            let largest_side = cubes[0][0].dimensions().0;

            gl::GenTextures(1, &mut cubemap_id);
            gl::BindTexture(gl::TEXTURE_CUBE_MAP, cubemap_id);

            let cubemap = Cubemap::from_id(
                facade,
                glium::texture::UncompressedFloatFormat::U8U8U8,
                cubemap_id,
                true,
                MipmapsOption::AutoGeneratedMipmapsMax(num_mips as u32),
                Dimensions::Cubemap {
                    dimension: largest_side,
                },
            );

            cubemap.generate_mipmaps();

            gl::BindTexture(gl::TEXTURE_CUBE_MAP, cubemap_id);

            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_MIN_FILTER,
                gl::LINEAR_MIPMAP_LINEAR as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_MAG_FILTER,
                gl::LINEAR as i32,
            );

            gl::GenerateMipmap(gl::TEXTURE_CUBE_MAP);

            for layer in 0..cubes.len() {
                let cube_orientation = cubes.remove(0);
                let dimensions = cube_orientation.front.dimensions();

                for side in 0..6 {
                    let mut pixels = cube_orientation[side].to_rgb8();

                    let flat_samples = pixels.as_flat_samples_mut();
                    let slice: &[u8] = flat_samples.as_slice();
                    let ptr: *const core::ffi::c_void =
                        slice as *const _ as *const core::ffi::c_void;
                    gl::TexImage2D(
                        gl::TEXTURE_CUBE_MAP_POSITIVE_X + side as u32,
                        layer as i32,
                        gl::RGB16F as i32,
                        dimensions.0 as i32,
                        dimensions.1 as i32,
                        0,
                        gl::RGB,
                        gl::UNSIGNED_BYTE,
                        ptr,
                    );
                }
            }

            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_MIN_FILTER,
                gl::LINEAR as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_MAG_FILTER,
                gl::LINEAR as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_S,
                gl::CLAMP_TO_EDGE as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_T,
                gl::CLAMP_TO_EDGE as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_R,
                gl::CLAMP_TO_EDGE as i32,
            );

            cubemap
        }
    }

    fn load_cubemap_mips(facade: &impl Facade, mut cubes: Vec<CubeOrientation>) -> Cubemap {
        unsafe {
            let mut cubemap_id: u32 = 0;
            let num_mips = cubes.len() - 1;
            let largest_side = cubes[0][0].dimensions().0;

            gl::GenTextures(1, &mut cubemap_id);
            gl::BindTexture(gl::TEXTURE_CUBE_MAP, cubemap_id);

            gl::TexParameteri(gl::TEXTURE_CUBE_MAP, gl::TEXTURE_BASE_LEVEL, 0);
            gl::TexParameteri(gl::TEXTURE_CUBE_MAP, gl::TEXTURE_MAX_LEVEL, num_mips as i32);

            for side in 0..6 {
                let dimensions = cubes[0].front.dimensions();

                gl::TexImage2D(
                    gl::TEXTURE_CUBE_MAP_POSITIVE_X + side as u32,
                    0,
                    gl::RGB16F as i32,
                    dimensions.0 as i32,
                    dimensions.1 as i32,
                    0,
                    gl::RGB,
                    gl::UNSIGNED_BYTE,
                    null(),
                );
            }

            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_MIN_FILTER,
                gl::LINEAR_MIPMAP_LINEAR as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_MAG_FILTER,
                gl::LINEAR as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_S,
                gl::CLAMP_TO_EDGE as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_T,
                gl::CLAMP_TO_EDGE as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_R,
                gl::CLAMP_TO_EDGE as i32,
            );

            let cubemap = Cubemap::from_id(
                facade,
                glium::texture::UncompressedFloatFormat::U8U8U8,
                cubemap_id,
                true,
                MipmapsOption::AutoGeneratedMipmaps,
                Dimensions::Cubemap {
                    dimension: largest_side,
                },
            );

            cubemap.generate_mipmaps();
            gl::BindTexture(gl::TEXTURE_CUBE_MAP, cubemap_id);
            gl::GenerateMipmap(gl::TEXTURE_CUBE_MAP);

            gl::BindTexture(gl::TEXTURE_CUBE_MAP, cubemap_id);

            for layer in 0..cubes.len() {
                let cube_orientation = cubes.remove(0);
                let dimensions = cube_orientation.front.dimensions();

                for side in 0..6 {
                    let mut pixels = cube_orientation[side].to_rgb8();

                    let flat_samples = pixels.as_flat_samples_mut();
                    let slice: &[u8] = flat_samples.as_slice();
                    let ptr: *const core::ffi::c_void =
                        slice as *const _ as *const core::ffi::c_void;
                    gl::TexImage2D(
                        gl::TEXTURE_CUBE_MAP_POSITIVE_X + side as u32,
                        layer as i32,
                        gl::RGB16F as i32,
                        dimensions.0 as i32,
                        dimensions.1 as i32,
                        0,
                        gl::RGB,
                        gl::UNSIGNED_BYTE,
                        ptr,
                    );
                }
            }

            cubemap
        }
    }
}

pub struct CubeOrientation {
    pub front: DynamicImage,
    pub back: DynamicImage,
    pub left: DynamicImage,
    pub right: DynamicImage,
    pub top: DynamicImage,
    pub bottom: DynamicImage,
}

impl CubeOrientation {
    pub fn new(
        right: DynamicImage,
        left: DynamicImage,
        top: DynamicImage,
        bottom: DynamicImage,
        front: DynamicImage,
        back: DynamicImage,
    ) -> Self {
        CubeOrientation {
            front,
            back,
            left,
            right,
            top,
            bottom,
        }
    }

    pub fn from_array(
        faces: impl IntoIterator<Item = DynamicImage>,
    ) -> Result<Self, Box<dyn Error>> {
        let mut iter = faces.into_iter();
        let error_msg = "Vector didn't have enough textures";
        Ok(CubeOrientation {
            right: iter.next().ok_or(error_msg)?,
            left: iter.next().ok_or(error_msg)?,
            top: iter.next().ok_or(error_msg)?,
            bottom: iter.next().ok_or(error_msg)?,
            front: iter.next().ok_or(error_msg)?,
            back: iter.next().ok_or(error_msg)?,
        })
    }
}

impl Index<usize> for CubeOrientation {
    type Output = DynamicImage;

    fn index(&self, index: usize) -> &Self::Output {
        match index {
            0 => &self.right,
            1 => &self.left,
            2 => &self.top,
            3 => &self.bottom,
            4 => &self.front,
            5 => &self.back,
            _ => panic!(
                "Index was out of bounds, CubeOrientation always has 6 elements, you accessed {}",
                index
            ),
        }
    }
}

use glium::backend::Facade;
use glium::texture::Cubemap;
use glium::texture::SrgbCubemap;
use glium::texture::{Dimensions, MipmapsOption};
use glium::uniforms::AsUniformValue;
use image::hdr::HdrDecoder;
use image::io::Reader as ImageReader;
use image::GenericImageView;
use std::fs::File;
use std::io::BufReader;
use std::path::PathBuf;

pub enum CubemapType {
    Cubemap(Cubemap),
    SrgbCubemap(SrgbCubemap),
}

impl From<Cubemap> for CubemapType {
    fn from(c: Cubemap) -> Self {
        Self::Cubemap(c)
    }
}
impl From<SrgbCubemap> for CubemapType {
    fn from(c: SrgbCubemap) -> Self {
        Self::SrgbCubemap(c)
    }
}

impl AsUniformValue for &CubemapType {
    fn as_uniform_value(&self) -> glium::uniforms::UniformValue<'_> {
        match self {
            CubemapType::Cubemap(c) => c.as_uniform_value(),
            CubemapType::SrgbCubemap(c) => c.as_uniform_value(),
        }
    }
}

impl AsUniformValue for CubemapType {
    fn as_uniform_value(&self) -> glium::uniforms::UniformValue<'_> {
        match self {
            CubemapType::Cubemap(c) => c.as_uniform_value(),
            CubemapType::SrgbCubemap(c) => c.as_uniform_value(),
        }
    }
}

pub struct CubemapLoader {}

impl CubemapLoader {
    fn create_paths(mut directory: PathBuf, extension: &str) -> Vec<PathBuf> {
        directory.push(format!("right.{}", extension));
        let path: PathBuf = directory.into();

        vec![
            path.with_file_name(format!("right.{}", extension)),
            path.with_file_name(format!("left.{}", extension)),
            path.with_file_name(format!("top.{}", extension)),
            path.with_file_name(format!("bottom.{}", extension)),
            path.with_file_name(format!("front.{}", extension)),
            path.with_file_name(format!("back.{}", extension)),
        ]
    }
    pub fn load_from_fs_hdr(
        directory: PathBuf,
        extension: &str,
        facade: &impl Facade,
    ) -> CubemapType {
        unsafe {
            let cubemap_id = Self::load_cubemap_gl(Self::create_paths(directory, extension));
            let cubemap = Cubemap::from_id(
                facade,
                glium::texture::UncompressedFloatFormat::F16F16F16,
                cubemap_id,
                true,
                MipmapsOption::AutoGeneratedMipmaps,
                Dimensions::Cubemap { dimension: 6 },
            );

            return cubemap.into();
        }
    }

    pub fn load_from_memory_hdr(
        images: Vec<Vec<f32>>,
        width: u32,
        height: u32,
        facade: &impl Facade,
    ) -> CubemapType {
        unsafe {
            let cubemap_id = Self::load_cubemap_gl_memory_hdr(images, width, height);
            let cubemap = Cubemap::from_id(
                facade,
                glium::texture::UncompressedFloatFormat::F16F16F16,
                cubemap_id,
                true,
                MipmapsOption::AutoGeneratedMipmaps,
                Dimensions::Cubemap { dimension: 6 },
            );

            return cubemap.into();
        }
    }
    // Creates a cubemap in raw opengl and then passes the id to glium for glium to manage.
    // I can't find any other way to create a cubemap in glium. This uses some C pointers so there is
    // a high likelihood that this is not robust and is quite easy to make the program panic
    pub fn load_from_fs(directory: PathBuf, extension: &str, facade: &impl Facade) -> CubemapType {
        let cubemap_id = Self::load_cubemap_gl(Self::create_paths(directory, extension));

        unsafe {
            let cubemap = Cubemap::from_id(
                facade,
                glium::texture::UncompressedFloatFormat::U8U8U8,
                cubemap_id,
                true,
                MipmapsOption::AutoGeneratedMipmaps,
                Dimensions::Cubemap { dimension: 6 },
            );

            return cubemap.into();
        }
    }

    fn load_cubemap_gl(faces: Vec<PathBuf>) -> u32 {
        unsafe {
            let mut texture_id: u32 = 0;

            gl::GenTextures(1, &mut texture_id);
            gl::BindTexture(gl::TEXTURE_CUBE_MAP, texture_id);

            for i in 0..faces.len() {
                let texture = ImageReader::open(&faces[i]).unwrap().decode().unwrap();

                let (width, height) = texture.dimensions();
                let mut pixels = texture.to_rgb8();

                let flat_samples = pixels.as_flat_samples_mut();
                let slice: &[u8] = flat_samples.as_slice();
                let ptr: *const core::ffi::c_void = slice as *const _ as *const core::ffi::c_void;

                gl::TexImage2D(
                    gl::TEXTURE_CUBE_MAP_POSITIVE_X + i as u32,
                    0,
                    gl::RGB as i32,
                    width as i32,
                    height as i32,
                    0,
                    gl::RGB,
                    gl::UNSIGNED_BYTE,
                    ptr,
                );
            }

            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_MIN_FILTER,
                gl::LINEAR as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_MAG_FILTER,
                gl::LINEAR as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_S,
                gl::CLAMP_TO_EDGE as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_T,
                gl::CLAMP_TO_EDGE as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_R,
                gl::CLAMP_TO_EDGE as i32,
            );

            return texture_id;
        }
    }

    fn load_cubemap_gl_hdr(faces: Vec<PathBuf>) -> u32 {
        unsafe {
            let mut texture_id: u32 = 0;

            gl::GenTextures(1, &mut texture_id);
            gl::BindTexture(gl::TEXTURE_CUBE_MAP, texture_id);

            for i in 0..faces.len() {
                let buffer = BufReader::new(File::open(&faces[i]).unwrap());
                let hdr_image = HdrDecoder::new(buffer).unwrap();
                let dimensions = (hdr_image.metadata().width, hdr_image.metadata().height);

                let output: Vec<f32> = hdr_image
                    .read_image_hdr()
                    .unwrap()
                    .into_iter()
                    .flat_map(|rgb| {
                        return {
                            let values = rgb.0;
                            values
                        };
                    })
                    .collect();
                let slice: &[f32] = output.as_slice();
                let ptr: *const core::ffi::c_void = slice as *const _ as *const core::ffi::c_void;

                gl::TexImage2D(
                    gl::TEXTURE_CUBE_MAP_POSITIVE_X + i as u32,
                    0,
                    gl::RGB16F as i32,
                    dimensions.0 as i32,
                    dimensions.1 as i32,
                    0,
                    gl::RGB,
                    gl::FLOAT,
                    ptr,
                );
            }

            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_MIN_FILTER,
                gl::LINEAR as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_MAG_FILTER,
                gl::LINEAR as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_S,
                gl::CLAMP_TO_EDGE as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_T,
                gl::CLAMP_TO_EDGE as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_R,
                gl::CLAMP_TO_EDGE as i32,
            );

            return texture_id;
        }
    }

    fn load_cubemap_gl_memory_hdr(images: Vec<Vec<f32>>, width: u32, height: u32) -> u32 {
        unsafe {
            let mut texture_id: u32 = 0;

            gl::GenTextures(1, &mut texture_id);
            gl::BindTexture(gl::TEXTURE_CUBE_MAP, texture_id);

            for i in 0..images.len() {
                let image = &images[i];
                let slice: &[f32] = image.as_slice();
                let ptr: *const core::ffi::c_void = slice as *const _ as *const core::ffi::c_void;

                gl::TexImage2D(
                    gl::TEXTURE_CUBE_MAP_POSITIVE_X + i as u32,
                    0,
                    gl::RGB16F as i32,
                    width as i32,
                    height as i32,
                    0,
                    gl::RGB,
                    gl::FLOAT,
                    ptr,
                );
            }

            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_MIN_FILTER,
                gl::LINEAR as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_MAG_FILTER,
                gl::LINEAR as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_S,
                gl::CLAMP_TO_EDGE as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_T,
                gl::CLAMP_TO_EDGE as i32,
            );
            gl::TexParameteri(
                gl::TEXTURE_CUBE_MAP,
                gl::TEXTURE_WRAP_R,
                gl::CLAMP_TO_EDGE as i32,
            );

            return texture_id;
        }
    }
}
